<meta charset="UTF-8"> 
<div id="gameDiv" style="display:none;">

	<div id="game" style="position:absolute;width:800px;height:600px">
		<canvas id="canvas" width="800" height="800" style="position:absolute;border:1px solid #000000;"></canvas>

		<canvas id="effect0" width="800" height="800" style="position:absolute;border:1px solid #000000;"></canvas>
		<canvas id="effect1" width="800" height="800" style="position:absolute;border:1px solid #000000;"></canvas>
		<canvas id="effect2" width="800" height="800" style="position:absolute;border:1px solid #000000;"></canvas>

		<canvas id="ctx-ui" width="800" height="800" style="position:absolute;border:1px solid #000000;"></canvas>
	</div>
</div>

<!--<script src="https://cdn.socket.io/socket.io-1.4.5.js"></script>-->
<script>
	//
	gameDiv.style.display = 'inline-block';

	var WIDTH = 800;
	var HEIGHT = WIDTH;

	var canvas = document.getElementById("canvas");
	var ctx = canvas.getContext("2d");

	var gfx0 = document.getElementById("effect0").getContext("2d");
	//var gfx1 = document.getElementById("effect1").getContext("2d");
	//var gfx2 = document.getElementById("effect2").getContext("2d");

	var ctxUi = document.getElementById("ctx-ui").getContext("2d");
	ctxUi.font = '30px Arial';

	gfx0.fillStyle = 'rgb(0,0,255)';
	ctx.fillStyle = 'rgb(0,0,127)';

	//gfx0.globalAlpha = 0.85;
	//gfx1.globalAlpha = 0.6;
	//gfx2.globalAlpha = 0.4;

	var World = function(){
		var self = this;

		self.tb = [[],[]];
		self.stepper = 0;
		self.friction = 0.999999
		
		self.lineLookup = [];

		self.solidTiles = [];
		self.tileSize = 1;
		self.halfSize = (self.tileSize/2)|0;
		self.gridSize = (WIDTH/self.tileSize)|0;
		self.edgeUR = 3;
		self.edgeDL = self.gridSize - self.edgeUR;
		
		self.wave = gfx0.createImageData(WIDTH, HEIGHT);
		self.c  = self.wave.data;
		
		for (var i = 0; i < self.gridSize; i++) {
			self.lineLookup[i] = i*self.gridSize;
			for (var j = 0; j < self.gridSize; j++) {
				self.c[4*(j*self.gridSize + i) + 3] = 255;
				self.tb[0]		[j*self.gridSize + i] = 0;
				self.tb[1]		[j*self.gridSize + i] = 0;
				self.solidTiles	[j*self.gridSize + i] = false;
				}
			}
		console.log(self.lineLookup[799]);
		self.draw = function(){
			//var bx =  WIDTH/2;
			//var by =  HEIGHT/2;

			var cur  = self.tb[self.stepper];
    		self.stepper = (self.stepper+1) % 2;
    		var old = self.tb[self.stepper];
    		self.c  = self.wave.data
			for (var x = self.edgeUR; x < self.edgeDL; x++) {
				var lc = self.lineLookup[x];
				var lu0 = self.lineLookup[x-1];
				var lu1 = self.lineLookup[x-2];

				var ld0 = self.lineLookup[x+1];
				var ld1 = self.lineLookup[x+2];

				for (var y = self.edgeUR; y < self.edgeDL; y++) {
					var index = lc+y;

					//Queen Waves
					old[index] = ( self.friction*( (	
										  cur[lu1+y ]+
							 cur[lu0+y-1]+cur[lu0+y ]+cur[lu0+y+1]+
				cur[lc+y-2 ]+cur[lc+y-1 ] 			 +cur[lc+y+1 ]+cur[lc+y+2 ]+
							 cur[ld0+y-1]+cur[ld0+y ]+cur[ld0+y+1]+
										  cur[ld1+y ]  						)/6 - old[index] ) ) | 0;

					var b = 64 + Math.abs(old[index]);
					self.c[4*(index) + 2] = b;
				}
			}
			gfx0.putImageData( self.wave, 0, 0);
		}
	}
	var WORLD = new World();

	setInterval(function(){
		ctx.fillRect(0,0,WIDTH,HEIGHT);
		gfx0.clearRect(0,0,WIDTH,HEIGHT);
		/*
		gfx1.clearRect(0,0,WIDTH,HEIGHT);
		gfx2.clearRect(0,0,WIDTH,HEIGHT);
		*/
		WORLD.draw();
	},1);

	var HOLDING = false
	var last = [0,0]
	document.onmousedown = function(event){
		HOLDING = true;
		var x = (event.clientX/WORLD.tileSize)|0;
		var y = (event.clientY/WORLD.tileSize)|0;
		WORLD.tb[WORLD.stepper][y*WORLD.gridSize + x] += 5000;

		last = [x,y];
	}
	document.onmouseup = function(event){
		HOLDING = false;
		var x = (event.clientX/WORLD.tileSize)|0;
		var y = (event.clientY/WORLD.tileSize)|0;
		WORLD.tb[WORLD.stepper][y*WORLD.gridSize + x] += 5000;

	}
	document.onmousemove = function(event){
		if (HOLDING){
			var x = (event.clientX/WORLD.tileSize)|0;
			var y = (event.clientY/WORLD.tileSize)|0;
			while (last[0] != x || last[1] != y ){
				if ( last[0] < WORLD.edgeDL && last[0] > WORLD.edgeUR  && last[1] > WORLD.edgeUR && last[1] < WORLD.edgeDL){
					WORLD.tb[WORLD.stepper][last[1]*WORLD.gridSize + last[0]] += 500;
				}
				last[0] += Math.sign( x - last[0] );
				last[1] += Math.sign( y - last[1] );
			}
		}
	}
	
</script>
